<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta property="og:title" content="Particle Life 2D">
        <meta property="og:site_name" content="lisyarus blog">
        <meta property="og:image" content="/webgpu/particle-life-cover.png" />
        <meta property="og:image:height" content="630" />
        <meta property="og:image:width" content="1200" />
        <title>Particle Life 2D</title>
        <link rel="icon" type="image/x-icon" href="/blog/assets/favicon.ico">
        <style>
            html, body {
                margin: 0 !important;
                padding: 0 !important;
            }
        </style>
        <script>

// From https://stackoverflow.com/a/47593316/2315602
function splitmix32(a) {
    return function() {
        a |= 0;
        a = a + 0x9e3779b9 | 0;
        let t = a ^ a >>> 16;
        t = Math.imul(t, 0x21f0aaad);
        t = t ^ t >>> 15;
        t = Math.imul(t, 0x735a2d97);
        return ((t = t ^ t >>> 15) >>> 0) / 4294967296;
    }
}

function randomSeed() {
    return (Math.random() * (2 ** 32)) >>> 0;
}

const particleDescription = 
`
struct Particle
{
    x : f32,
    y : f32,
    vx : f32,
    vy : f32,
    sx: f32,
    sy: f32,
    ax: f32,
    ay: f32,
}
`;

const simulationOptionsDescription =
`
struct SimulationOptions
{
    left : f32,
    right : f32,
    bottom : f32,
    top : f32,
    friction : f32,
    mass: f32,
    dt : f32,
    binSize : f32,
    maxForceStrength : f32,
    loopingBorders : f32,
    actionX : f32,
    actionY : f32,
    actionVX : f32,
    actionVY : f32,
    actionForce : f32,
    actionRadius : f32,
    radius: f32,
    collisionStrength : f32,
    collisionRadius: f32,
    time : f32,
    copyRadius : f32,
    copyProbability : f32,
    copyCosSimThreshold : f32,
}

struct BinInfo
{
    gridSize : vec2i,
    binId : vec2i,
    binIndex : i32,
}

fn getBinInfo(position : vec2f, simulationOptions : SimulationOptions) -> BinInfo
{
    let gridSize = vec2i(
        i32(ceil((simulationOptions.right - simulationOptions.left) / simulationOptions.binSize)),
        i32(ceil((simulationOptions.top - simulationOptions.bottom) / simulationOptions.binSize)),
    );

    let binId = vec2i(
        clamp(i32(floor((position.x - simulationOptions.left) / simulationOptions.binSize)), 0, gridSize.x - 1),
        clamp(i32(floor((position.y - simulationOptions.bottom) / simulationOptions.binSize)), 0, gridSize.y - 1)
    );

    let binIndex = binId.y * gridSize.x + binId.x;

    return BinInfo(gridSize, binId, binIndex);
}
`;

const binFillSizeShader = 
`
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read> particles : array<Particle>;

@group(1) @binding(0) var<uniform> simulationOptions : SimulationOptions;

@group(2) @binding(0) var<storage, read_write> binSize : array<atomic<u32>>;

@compute @workgroup_size(64)
fn clearBinSize(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&binSize)) {
        return;
    }

    atomicStore(&binSize[id.x], 0u);
}

@compute @workgroup_size(64)
fn fillBinSize(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&particles)) {
        return;
    }

    let particle = particles[id.x];

    let binIndex = getBinInfo(vec2f(particle.x, particle.y), simulationOptions).binIndex;

    atomicAdd(&binSize[binIndex + 1], 1u);
}
`;

const binPrefixSumShader = 
`
@group(0) @binding(0) var<storage, read> source : array<u32>;
@group(0) @binding(1) var<storage, read_write> destination : array<u32>;
@group(0) @binding(2) var<uniform> stepSize : u32;

@compute @workgroup_size(64)
fn prefixSumStep(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&source)) {
        return;
    }

    if (id.x < stepSize) {
        destination[id.x] = source[id.x];
    } else {
        destination[id.x] = source[id.x - stepSize] + source[id.x];
    }
}
`;

const particleSortShader = 
`
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read> source : array<Particle>;
@group(0) @binding(1) var<storage, read_write> destination : array<Particle>;
@group(0) @binding(2) var<storage, read> binOffset : array<u32>;
@group(0) @binding(3) var<storage, read_write> binSize : array<atomic<u32>>;

@group(1) @binding(0) var<uniform> simulationOptions : SimulationOptions;

@compute @workgroup_size(64)
fn clearBinSize(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&binSize)) {
        return;
    }

    atomicStore(&binSize[id.x], 0u);
}

@compute @workgroup_size(64)
fn sortParticles(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&source)) {
        return;
    }

    let particle = source[id.x];

    let binIndex = getBinInfo(vec2f(particle.x, particle.y), simulationOptions).binIndex;

    let newParticleIndex = binOffset[binIndex] + atomicAdd(&binSize[binIndex], 1);
    destination[newParticleIndex] = particle;
}
`;

const particleComputeForcesShader = 
`
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read> particlesSource : array<Particle>;
@group(0) @binding(1) var<storage, read_write> particlesDestination : array<Particle>;
@group(0) @binding(2) var<storage, read> binOffset : array<u32>;

@group(1) @binding(0) var<uniform> simulationOptions : SimulationOptions;

fn hash( x: u32 ) -> u32 {
    var u = x;
    u += ( u << 10u );
    u ^= ( u >>  6u );
    u += ( u <<  3u );
    u ^= ( u >> 11u );
    u += ( u << 15u );
    return u;
}

fn random( f: f32 ) -> f32 {
    let mantissaMask = 0x007FFFFFu;
    let one          = 0x3F800000u;

    var h = hash( bitcast<u32>(f) );
    h &= mantissaMask;
    h |= one;
    
    let r2 = bitcast<f32>( h );
    return r2 - 1.0;
}

fn random2( v: vec2f ) -> f32 { return random( v.x + v.y * 57.0 ); }
fn random3( v: vec3f ) -> f32 { return random( v.x + v.y * 57.0 + v.z * 113.0 ); }
fn random4( v: vec4f ) -> f32 { return random( v.x + v.y * 57.0 + v.z * 113.0 + v.w * 197.0 ); }

@compute @workgroup_size(64)
fn computeForces(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&particlesSource)) {
        return;
    }

    var particle = particlesSource[id.x];
    let alpha = vec2f(particle.ax, particle.ay);
    let particleSpecies = vec2f(particle.sx, particle.sy);

    let binInfo = getBinInfo(vec2f(particle.x, particle.y), simulationOptions);

    let loopingBorders = simulationOptions.loopingBorders == 1.0;

    var binXMin = binInfo.binId.x - 1;
    var binYMin = binInfo.binId.y - 1;

    var binXMax = binInfo.binId.x + 1;
    var binYMax = binInfo.binId.y + 1;

    if (!loopingBorders) {
        binXMin = max(0, binXMin);
        binYMin = max(0, binYMin);
        binXMax = min(binInfo.gridSize.x - 1, binXMax);
        binYMax = min(binInfo.gridSize.y - 1, binYMax);
    }

    let width = simulationOptions.right - simulationOptions.left;
    let height = simulationOptions.top - simulationOptions.bottom;

    var totalForce = vec2f(0.0, 0.0);

    let particlePosition = vec2f(particle.x, particle.y);
    let copyBinXRand = random3(vec3f(simulationOptions.time, particle.x, particle.y));
    let copyBinYRand = random4(vec4f(simulationOptions.time, particle.y, particle.x, particle.vx));
    let copyBinXOffset = i32(floor(copyBinXRand * 3.0)) - 1;
    let copyBinYOffset = i32(floor(copyBinYRand * 3.0)) - 1;

    for (var binX = binXMin; binX <= binXMax; binX += 1) {
        for (var binY = binYMin; binY <= binYMax; binY += 1) {
            var realBinX = (binX + binInfo.gridSize.x) % binInfo.gridSize.x;
            var realBinY = (binY + binInfo.gridSize.y) % binInfo.gridSize.y;

            let binIndex = realBinY * binInfo.gridSize.x + realBinX;
            let binStart = binOffset[binIndex];
            let binEnd = binOffset[binIndex + 1];

            for (var j = binStart; j < binEnd; j += 1) {
                if (j == id.x) {
                    continue;
                }

                let other = particlesSource[j];
                let otherSpecies = vec2f(other.sx, other.sy);

                let forceStrength = dot(alpha, otherSpecies) * simulationOptions.maxForceStrength;

                var r = vec2f(other.x, other.y) - particlePosition;

                if (loopingBorders) {
                    if (abs(r.x) >= width * 0.5) {
                        r.x -= sign(r.x) * width;
                    }

                    if (abs(r.y) >= height * 0.5) {
                        r.y -= sign(r.y) * height;
                    }
                }

                let d = length(r);
                if (d > 0.0 && d < simulationOptions.radius) {
                    let n = r / d;

                    var totalForceMag = 0.0;
                    if (d < simulationOptions.collisionRadius) {
                        totalForceMag = max(0.0, simulationOptions.collisionRadius - d) * -simulationOptions.collisionStrength;
                    } else {
                        let forceRegion = simulationOptions.radius - simulationOptions.collisionRadius;
                        totalForceMag = forceStrength * max(0.0, 1.0 - abs(2 * d - forceRegion) / forceRegion);
                    }

                    totalForce += totalForceMag * n;
                }

                if (binX == binInfo.binId.x + copyBinXOffset && binY == binInfo.binId.y + copyBinYOffset) {
                    // check if we should copy this other particle's genes
                    if (d < simulationOptions.copyRadius) {
                        let speciesCosSim = dot(particleSpecies, otherSpecies) / (length(particleSpecies) * length(otherSpecies) + 1e-6);

                        if (speciesCosSim > simulationOptions.copyCosSimThreshold) {
                            let p = random3(vec3f(simulationOptions.time, particle.x, other.x));
                            if (p < simulationOptions.copyProbability) {
                                particle.sx = other.sx;
                                particle.sy = other.sy;
                                particle.ax = other.ax;
                                particle.ay = other.ay;
                            }
                        }
                    }
                }
            }
        }
    }

    let mu = pow(0.5, simulationOptions.dt / simulationOptions.friction);
    particle.vx *= mu;
    particle.vy *= mu;

    // Assume mass = 1
    particle.vx += totalForce.x * simulationOptions.dt / simulationOptions.mass;
    particle.vy += totalForce.y * simulationOptions.dt / simulationOptions.mass;

    particlesDestination[id.x] = particle;
}
`;

const particleAdvanceShader =
`
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read_write> particles : array<Particle>;

@group(1) @binding(0) var<uniform> simulationOptions : SimulationOptions;

@compute @workgroup_size(64)
fn particleAdvance(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&particles)) {
        return;
    }

    let width = simulationOptions.right - simulationOptions.left;
    let height = simulationOptions.top - simulationOptions.bottom;

    var particle = particles[id.x];

    var actionR = vec2f(particle.x, particle.y) - vec2f(simulationOptions.actionX, simulationOptions.actionY);
    if (simulationOptions.loopingBorders == 1.0) {
        if (abs(actionR.x) >= width * 0.5) {
            actionR.x -= sign(actionR.x) * width;
        }

        if (abs(actionR.y) >= height * 0.5) {
            actionR.y -= sign(actionR.y) * height;
        }
    }
    let actionFactor = simulationOptions.actionForce * exp(- dot(actionR, actionR) / (simulationOptions.actionRadius * simulationOptions.actionRadius));
    particle.vx += simulationOptions.actionVX * actionFactor;
    particle.vy += simulationOptions.actionVY * actionFactor;

    particle.x += particle.vx * simulationOptions.dt;
    particle.y += particle.vy * simulationOptions.dt;

    let loopingBorders = simulationOptions.loopingBorders == 1.0;

    if (loopingBorders) {
        if (particle.x < simulationOptions.left) {
            particle.x += width;
        }
    
        if (particle.x > simulationOptions.right) {
            particle.x -= width;
        }

        if (particle.y < simulationOptions.bottom) {
            particle.y += height;
        }
    
        if (particle.y > simulationOptions.top) {
            particle.y -= height;
        }
    } else {
        if (particle.x < simulationOptions.left) {
            particle.x = simulationOptions.left;
            particle.vx *= -1.0;
        }

        if (particle.x > simulationOptions.right) {
            particle.x = simulationOptions.right;
            particle.vx *= -1.0;
        }

        if (particle.y < simulationOptions.bottom) {
            particle.y = simulationOptions.bottom;
            particle.vy *= -1.0;
        }

        if (particle.y > simulationOptions.top) {
            particle.y = simulationOptions.top;
            particle.vy *= -1.0;
        }
    }

    particles[id.x] = particle;
}
`;

const particleRenderShader =
`
${particleDescription}

struct Camera
{
    center : vec2f,
    extent : vec2f,
    pixelsPerUnit : f32,
}

@group(0) @binding(0) var<storage, read> particles : array<Particle>;

@group(1) @binding(0) var<uniform> camera : Camera;

struct CircleVertexOut
{
    @builtin(position) position : vec4f,
    @location(0) offset : vec2f,
    @location(1) color : vec4f,
}

const offsets = array<vec2f, 6>(
    vec2f(-1.0, -1.0),
    vec2f( 1.0, -1.0),
    vec2f(-1.0,  1.0),
    vec2f(-1.0,  1.0),
    vec2f( 1.0, -1.0),
    vec2f( 1.0,  1.0),
);

@vertex
fn vertexGlow(@builtin(vertex_index) id : u32) -> CircleVertexOut
{
    let particle = particles[id / 6u];
    let offset = offsets[id % 6u];
    let position = vec2f(particle.x, particle.y) + 12.0 * offset;
    return CircleVertexOut(
        vec4f((position - camera.center) / camera.extent, 0.0, 1.0),
        offset,
        vec4f(1.0, abs(particle.sx), abs(particle.sy), 1.0)
    );
}

@fragment
fn fragmentGlow(in : CircleVertexOut) -> @location(0) vec4f
{
    let l = length(in.offset);
    let alpha = exp(- 6.0 * l * l) / 256.0;
    return in.color * vec4f(1.0, 1.0, 1.0, alpha);
}

@vertex
fn vertexCircle(@builtin(vertex_index) id : u32) -> CircleVertexOut
{
    let particle = particles[id / 6u];
    let offset = offsets[id % 6u] * 1.5;
    let position = vec2f(particle.x, particle.y) + offset;
    return CircleVertexOut(
        vec4f((position - camera.center) / camera.extent, 0.0, 1.0),
        offset,
        vec4f(1.0, abs(particle.sx), abs(particle.sy), 1.0)
    );
}

@fragment
fn fragmentCircle(in : CircleVertexOut) -> @location(0) vec4f
{
    let alpha = clamp(camera.pixelsPerUnit - length(in.offset) * camera.pixelsPerUnit + 0.5, 0.0, 1.0);
    return in.color * vec4f(1.0, 1.0, 1.0, alpha);
}

@vertex
fn vertexPoint(@builtin(vertex_index) id : u32) -> CircleVertexOut
{
    let particle = particles[id / 6u];
    let offset = 2.0 * offsets[id % 6u] / camera.pixelsPerUnit;
    let position = vec2f(particle.x, particle.y) + offset;
    return CircleVertexOut(
        vec4f((position - camera.center) / camera.extent, 0.0, 1.0),
        offset,
        vec4f(1.0, abs(particle.sx), abs(particle.sy), 1.0)
    );
}

const PI = 3.1415926535;

@fragment
fn fragmentPoint(in : CircleVertexOut) -> @location(0) vec4f
{
    let d = max(vec2(0.0), min(in.offset * camera.pixelsPerUnit + 0.5, vec2(camera.pixelsPerUnit)) - max(in.offset * camera.pixelsPerUnit - 0.5, - vec2(camera.pixelsPerUnit)));
    let alpha = (PI / 4.0) * d.x * d.y;
    return vec4f(in.color.rgb, in.color.a * alpha);
}
`;

const composeShader =
`
@group(0) @binding(0) var hdrTexture : texture_2d<f32>;
@group(0) @binding(1) var blueNoiseTexture : texture_2d<f32>;

const vertices = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f( 3.0, -1.0),
    vec2f(-1.0,  3.0),
);

struct VertexOut
{
    @builtin(position) position : vec4f,
    @location(0) texcoord : vec2f,
}

@vertex
fn vertexMain(@builtin(vertex_index) id : u32) -> VertexOut
{
    let vertex = vertices[id];
    return VertexOut(
        vec4f(vertex, 0.0, 1.0),
        vertex * 0.5 + vec2f(0.5)
    );
}

fn acesTonemap(x : vec3f) -> vec3f
{
    let a = 2.51;
    let b = 0.03;
    let c = 2.43;
    let d = 0.59;
    let e = 0.14;
    return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec3f(0.0), vec3f(1.0));
}

fn maxTonemap(x : vec3f) -> vec3f
{
    let m = max(1.0, max(x.r, max(x.g, x.b)));
    return x / m;
}

fn uncharted2TonemapImpl(x : vec3f) -> vec3f
{
    let A = 0.15;
    let B = 0.50;
    let C = 0.10;
    let D = 0.20;
    let E = 0.02;
    let F = 0.30;

    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

fn uncharted2Tonemap(x : vec3f) -> vec3f
{
    let exposure = 5.0;
    let white = 10.0;
    return uncharted2TonemapImpl(x * exposure) / uncharted2TonemapImpl(vec3f(white));
}

fn agxTonemap(x : vec3f) -> vec3f
{
    const M1 = mat3x3f(0.842, 0.0423, 0.0424, 0.0784, 0.878, 0.0784, 0.0792, 0.0792, 0.879);
    const M2 = mat3x3f(1.2, -0.053, -0.053, -0.1, 1.15, -0.1, -0.1, -0.1, 1.15);
    const c1 = 12.47393;
    const c2 = 16.5;

    var result = x * 0.5;
    result = M1 * result;
    result = clamp((log2(result) + c1) / c2, vec3f(0.0), vec3f(1.0));
    result = 0.5 + 0.5 * sin(((-3.11 * result + 6.42) * result - 0.378) * result - 1.44);
    result = M2 * result;

    return result;
}

fn dither(x : vec3f, n : f32) -> vec3f
{
    let c = x * 255.0;
    let c0 = floor(c);
    let c1 = c0 + vec3f(1.0);
    let dc = c - c0;

    var r = c0;
    if (dc.r > n) { r.r = c1.r; }
    if (dc.g > n) { r.g = c1.g; }
    if (dc.b > n) { r.b = c1.b; }

    return r / 255.0;
}

@fragment
fn fragmentMain(in : VertexOut) -> @location(0) vec4f
{
    var sample = textureLoad(hdrTexture, vec2i(in.position.xy), 0); 
    let noise = textureLoad(blueNoiseTexture, vec2u(in.position.xy) % textureDimensions(blueNoiseTexture), 0).r;

    var color = sample.rgb;
    color = acesTonemap(color);
    color = pow(color, vec3f(1.0 / 2.2));
    color = dither(color, noise);

    return vec4f(color, 1.0);
}
`;

var canvas;
var context;
var surfaceFormat;
var device;

const hdrFormat = 'rgba16float';

var timestampQuerySupported = true;

const maxForceRadius = 0.2;
const initialVelocity = 0.0;

var speciesDim = 2;
var particleCount = 16384;
var simulationBox = [[-4, 4], [-4, 4]];
var friction = 0.001;
var mass = 0.02;
var loopingBorders = false;
var gridSize = [Math.ceil((simulationBox[0][1] - simulationBox[0][0]) / maxForceRadius), Math.ceil((simulationBox[1][1] - simulationBox[1][0]) / maxForceRadius)];
var binCount = gridSize[0] * gridSize[1];
var prefixSumIterations = Math.ceil(Math.ceil(Math.log2(binCount + 1)) / 2) * 2;

var customRules = false;

var currentSystemDescription;

var particleBuffer;
var particleTempBuffer;
var binOffsetBuffer;
var binOffsetTempBuffer;
var binPrefixSumStepSizeBuffer;
var cameraBuffer;
var simulationOptionsBuffer;

var blueNoiseTexture;
var blueNoiseTextureView;
var hdrTexture;
var hdrTextureView;

var particleBufferBindGroupLayout;
var particleBufferReadOnlyBindGroupLayout;
var cameraBindGroupLayout;
var simulationOptionsBindGroupLayout;
var binFillSizeBindGroupLayout;
var binPrefixSumBindGroupLayout;
var particleSortBindGroupLayout;
var particleComputeForcesBindGroupLayout;
var composeBindGroupLayout;

var particleBufferBindGroup;
var particleBufferReadOnlyBindGroup;
var binFillSizeBindGroup;
var binPrefixSumBindGroup = [null, null];
var particleSortBindGroup;
var particleComputeForcesBindGroup;
var cameraBindGroup;
var simulationOptionsBindGroup;
var composeBindGroup;

var binClearSizePipeline;
var binFillSizePipeline;
var binPrefixSumPipeline;
var particleSortClearSizePipeline;
var particleSortPipeline;
var particleComputeForcesPipeline;
var particleAdvancePipeline;
var particleRenderGlowPipeline;
var particleRenderPipeline;
var particleRenderPointPipeline;
var composePipeline;

var cameraCenter = [0.0, 0.0];
var cameraExtentX = simulationBox[0][1];
var cameraExtentY = simulationBox[1][1];
var cameraExtentXTarget = simulationBox[0][1];

var zoomAnchor = null;

var lastFrameTimestamp = window.performance.now() / 1000.0;

var mouseDrag = null;
var actionPoint = null;
var actionDrag = null;

const activeTouches = new Map();
var lastTouchTime = null;
var isDoubleTap = false;

var frameID = 0;
var framesInFlight = 0;

var paused = false;
var toolsPanelShown = true;
var debugPanelShown = false;

var freeQueryHelpers = [];

function QueryHelper()
{
    this.querySet = device.createQuerySet({
        count: 16,
        type: 'timestamp',
    });

    this.resolveBuffer = device.createBuffer({
        size: 8 * 16,
        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE,
    });

    this.readBuffer = device.createBuffer({
        size: 8 * 16,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });

    this.currentIndex = 0;
    this.start = () => this.currentIndex = 0;
    this.next = () => {
        const result = {
            querySet: this.querySet,
            beginningOfPassWriteIndex: this.currentIndex,
            endOfPassWriteIndex: this.currentIndex + 1,
        };
        this.currentIndex += 2;
        return result;
    };
}

function formatExecutionTime(x) {
    var result = (Number(x) / 1000000).toFixed(2);
    while (result.length < 5) {
        result = " " + result;
    }
    return result + " ms";
}

function redraw()
{
    if (framesInFlight > 3) {
        requestAnimationFrame(redraw);
        return;
    }

    const now = window.performance.now() / 1000.0;

    const dt = 0.001;
    lastFrameTimestamp = now;

    const aspectRatio = canvas.width / canvas.height;
    const cameraExtentXDelta = (cameraExtentXTarget - cameraExtentX) * (- Math.expm1(- 20 * dt));

    cameraExtentX += cameraExtentXDelta;
    cameraExtentY = cameraExtentX / aspectRatio;

    if (zoomAnchor) {
        cameraCenter[0] -= cameraExtentXDelta * zoomAnchor[0];
        cameraCenter[1] -= cameraExtentXDelta * zoomAnchor[1] / aspectRatio;
    }

    const pixelsPerUnit = canvas.width / (2.0 * cameraExtentX);

    const toolsPanel = document.getElementById("toolsPanel");
    var toolsPanelAlpha = Number(toolsPanel.style.opacity);
    toolsPanelAlpha += ((toolsPanelShown ? 1.0 : 0.0) - toolsPanelAlpha) * (- Math.expm1(- 20 * dt));
    toolsPanel.style.opacity = toolsPanelAlpha;
    toolsPanel.style.visibility = (toolsPanelAlpha < 0.01) ? "hidden" : "visible";

    const debugPanel = document.getElementById("debugPanel");
    var debugPanelAlpha = Number(debugPanel.style.opacity);
    debugPanelAlpha += ((debugPanelShown ? 1.0 : 0.0) - debugPanelAlpha) * (- Math.expm1(- 20 * dt));
    debugPanel.style.opacity = debugPanelAlpha;
    debugPanel.style.visibility = (debugPanelAlpha < 0.01) ? "hidden" : "visible";

    const simDt = 0.001;

    const frictionFactor = 0.001;//Math.exp(- simDt * friction);

    const actionX = actionPoint ? cameraCenter[0] + cameraExtentX * (2.0 * actionPoint[0] / canvas.width - 1.0) : 0.0;
    const actionY = actionPoint ? cameraCenter[1] + cameraExtentY * (1.0 - 2.0 * actionPoint[1] / canvas.height) : 0.0;
    const actionVX = actionDrag ? cameraExtentX * (2.0 * actionDrag[0] / canvas.width) : 0.0;
    const actionVY = actionDrag ? cameraExtentY * (- 2.0 * actionDrag[1] / canvas.height) : 0.0;
    const actionForce = actionPoint ? 20.0 : 0.0;
    const actionRadius = cameraExtentX / 16.0;

    actionDrag = [0.0, 0.0];

    device.queue.writeBuffer(simulationOptionsBuffer, 0, new Float32Array([
        simulationBox[0][0],
        simulationBox[0][1],
        simulationBox[1][0],
        simulationBox[1][1],
        frictionFactor,
        mass,
        simDt,
        maxForceRadius,
        currentSystemDescription.maxForceStrength,
        loopingBorders ? 1.0 : 0.0,
        actionX,
        actionY,
        actionVX,
        actionVY,
        actionForce,
        actionRadius,
        currentSystemDescription.radius,
        currentSystemDescription.collisionStrength,
        currentSystemDescription.collisionRadius,
        now,
        currentSystemDescription.copyRadius,
        currentSystemDescription.copyProbability,
        currentSystemDescription.copyCosSimThreshold,
    ]));
    device.queue.writeBuffer(cameraBuffer, 0, new Float32Array([cameraCenter[0], cameraCenter[1], cameraExtentX, cameraExtentY, pixelsPerUnit]));

    var queryHelper;
    if (timestampQuerySupported) {
        if (freeQueryHelpers.length > 0) {
            queryHelper = freeQueryHelpers.pop();
        } else {
            queryHelper = new QueryHelper();
        }
        queryHelper.start();
    }
 
    const encoder = device.createCommandEncoder({});

    if (!paused) {
        encoder.copyBufferToBuffer(particleBuffer, 0, particleTempBuffer, 0, particleBuffer.size);

        const binningComputePass = encoder.beginComputePass({
            ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
        });

        binningComputePass.setBindGroup(0, particleBufferReadOnlyBindGroup);
        binningComputePass.setBindGroup(1, simulationOptionsBindGroup);
        binningComputePass.setBindGroup(2, binFillSizeBindGroup);
        binningComputePass.setPipeline(binClearSizePipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil((binCount + 1) / 64));
        binningComputePass.setPipeline(binFillSizePipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));

        binningComputePass.setPipeline(binPrefixSumPipeline);
        for (var i = 0; i < prefixSumIterations; ++i) {
            binningComputePass.setBindGroup(0, binPrefixSumBindGroup[i % 2], [i * 256]);
            binningComputePass.dispatchWorkgroups(Math.ceil((binCount + 1) / 64));
        }

        binningComputePass.setBindGroup(0, particleSortBindGroup);
        binningComputePass.setPipeline(particleSortClearSizePipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil((binCount + 1) / 64));
        binningComputePass.setPipeline(particleSortPipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));

        binningComputePass.end();

        const forcesComputePass = encoder.beginComputePass({
            ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
        });

        forcesComputePass.setBindGroup(0, particleComputeForcesBindGroup);
        forcesComputePass.setBindGroup(1, simulationOptionsBindGroup);
        forcesComputePass.setPipeline(particleComputeForcesPipeline);
        forcesComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));

        forcesComputePass.end();

        const advanceComputePass = encoder.beginComputePass({
            ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
        });

        advanceComputePass.setBindGroup(0, particleBufferBindGroup);
        advanceComputePass.setBindGroup(1, simulationOptionsBindGroup);
        advanceComputePass.setPipeline(particleAdvancePipeline);
        advanceComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));

        advanceComputePass.end();
    }
 
    const hdrRenderPass = encoder.beginRenderPass({
        colorAttachments: [
            {
                view: hdrTextureView,
                clearValue: [0.001, 0.001, 0.001, 0.0],
                loadOp: 'clear',
                storeOp: 'store',
            },
        ],
        ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
        // timestampWrites: [
        //     {
        //         location: 'beginning',
        //         querySet: queryHelper.querySet,
        //         queryIndex: 6,
        //     },
        //     {
        //         location: 'end',
        //         querySet: queryHelper.querySet,
        //         queryIndex: 7,
        //     },
        // ],
    });
    hdrRenderPass.setBindGroup(0, particleBufferReadOnlyBindGroup);
    hdrRenderPass.setBindGroup(1, cameraBindGroup);
    hdrRenderPass.setPipeline(particleRenderGlowPipeline);
    hdrRenderPass.draw(particleCount * 6);
    if (pixelsPerUnit < 1.0) {
        hdrRenderPass.setPipeline(particleRenderPointPipeline);
        hdrRenderPass.draw(particleCount * 6);
    } else {
        hdrRenderPass.setPipeline(particleRenderPipeline);
        hdrRenderPass.draw(particleCount * 6);
    }
    hdrRenderPass.end();
 
    const composeRenderPass = encoder.beginRenderPass({
        colorAttachments: [
            {
                view: context.getCurrentTexture().createView(),
                clearValue: [0, 0, 0, 0],
                loadOp: 'clear',
                storeOp: 'store',
            },
        ],
        ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
    });
    composeRenderPass.setBindGroup(0, composeBindGroup);
    composeRenderPass.setPipeline(composePipeline);
    composeRenderPass.draw(3);
    composeRenderPass.end();

    if (timestampQuerySupported) {
        encoder.resolveQuerySet(queryHelper.querySet, 0, queryHelper.querySet.count, queryHelper.resolveBuffer, 0);
        encoder.copyBufferToBuffer(queryHelper.resolveBuffer, 0, queryHelper.readBuffer, 0, queryHelper.resolveBuffer.size);
    }
 
    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    if (timestampQuerySupported) {
        queryHelper.readBuffer.mapAsync(GPUMapMode.READ).then(() => {
            const values = new BigUint64Array(queryHelper.readBuffer.getMappedRange());
            var debugText = "";
            debugText += "Binning: " + (paused ? " -------" : formatExecutionTime(values[1] - values[0])) + "\n";
            debugText += "Forces:  " + (paused ? " -------" : formatExecutionTime(values[3] - values[2])) + "\n";
            debugText += "Advance: " + (paused ? " -------" : formatExecutionTime(values[5] - values[4])) + "\n";
            debugText += "Render:  " + formatExecutionTime(values[7] - values[6]) + "\n";
            debugText += "Compose: " + formatExecutionTime(values[9] - values[8]) + "\n";
            document.getElementById("debugInfo").innerText = debugText;
            queryHelper.readBuffer.unmap();
            freeQueryHelpers.push(queryHelper);
        });
    }

    ++framesInFlight;

    device.queue.onSubmittedWorkDone().then(() => { --framesInFlight; });

    ++frameID;

    requestAnimationFrame(redraw);
}

function centerView()
{
    cameraCenter = [0.0, 0.0];
    zoomAnchor = null;

    const aspectRatio = document.body.clientWidth / document.body.clientHeight;

    if ((simulationBox[0][1] - simulationBox[0][0]) / (simulationBox[1][1] - simulationBox[1][0]) > aspectRatio)
        cameraExtentXTarget = simulationBox[0][1];
    else
        cameraExtentXTarget = simulationBox[1][1] * aspectRatio;
}

function loadSystem(systemDescription)
{
    currentSystemDescription = systemDescription;

    particleCount = systemDescription.particleCount;

    if (systemDescription.friction == undefined)
        systemDescription.friction = 0.001;

    if (systemDescription.loopingBorders == undefined)
        systemDescription.loopingBorders = false;

    friction = systemDescription.friction;
    loopingBorders = systemDescription.loopingBorders;

    customRules = false;

    const W = Math.round(systemDescription.simulationSize[0]);
    const H = Math.round(systemDescription.simulationSize[1]);

    simulationBox = [[-W, W], [-H, H]];

    document.getElementById("particleCountSlider").value = Math.round(Math.log2(particleCount));
    document.getElementById("particleCountText").innerText = `${particleCount} particles`;
    document.getElementById("simulationWidthSlider").value = Math.round(systemDescription.simulationSize[0]);
    document.getElementById("simulationWidthText").innerText = `Width: ${2 * W}`;
    document.getElementById("simulationHeightSlider").value = Math.round(systemDescription.simulationSize[1]);
    document.getElementById("simulationHeightText").innerText = `Height: ${2 * H}`;
    document.getElementById("frictionSlider").value = Math.round(friction);
    document.getElementById("frictionText").innerText = `Friction: ${friction}`;
    document.getElementById("loopingBorders").checked = loopingBorders;
    document.getElementById("maxForceStrengthSlider").value = systemDescription.maxForceStrength;
    document.getElementById("maxForceStrengthText").innerText = `Max force strength: ${systemDescription.maxForceStrength.toFixed(1)}`;
    document.getElementById("forceRadiusSlider").value = systemDescription.radius;
    document.getElementById("forceRadiusText").innerText = `Force radius: ${systemDescription.radius.toFixed(1)}`;
    document.getElementById("collisionStrengthSlider").value = systemDescription.collisionStrength;
    document.getElementById("collisionStrengthText").innerText = `Collision strength: ${systemDescription.collisionStrength.toFixed(1)}`;
    document.getElementById("collisionRadiusSlider").value = systemDescription.collisionRadius;
    document.getElementById("collisionRadiusText").innerText = `Collision radius: ${systemDescription.collisionRadius.toFixed(2)}`;
    document.getElementById("copyRadiusSlider").value = systemDescription.copyRadius;
    document.getElementById("copyRadiusText").innerText = `Species copy radius: ${systemDescription.copyRadius.toFixed(1)}`;
    document.getElementById("copyProbSlider").value = (systemDescription.copyProbability).toFixed(1);
    document.getElementById("copyProbText").innerText = `Species copy probability: ${(systemDescription.copyProbability).toFixed(1)}%`;
    document.getElementById("copyCosSimThresholdSlider").value = (systemDescription.copyCosSimThreshold).toFixed(1);
    document.getElementById("copyCosSimThresholdText").innerText = `Species copy cosine similarity threshold: ${(systemDescription.copyCosSimThreshold).toFixed(1)}`;

    gridSize = [Math.ceil((simulationBox[0][1] - simulationBox[0][0]) / maxForceRadius), Math.ceil((simulationBox[1][1] - simulationBox[1][0]) / maxForceRadius)];
    binCount = gridSize[0] * gridSize[1];
    prefixSumIterations = Math.ceil(Math.ceil(Math.log2(binCount + 1)) / 2) * 2;

    let particleStructSize = 8
    const initialParticles = new Float32Array(particleCount * particleStructSize);

    const minBinSpecies = 1;
    const maxBinSpecies = 3;

    // initialize different species sets in each bin
    for (var i = 0; i < gridSize[0]; ++i) {
        for (var j = 0; j < gridSize[1]; ++j) {
            const binIndex = j * gridSize[0] + i;
            const binStart = Math.floor(particleCount * binIndex / binCount);
            let binEnd;
            if (i == gridSize[0] - 1 && j == gridSize[1] - 1) {
                binEnd = particleCount;
            } else {
                binEnd = Math.floor(particleCount * (binIndex + 1) / binCount);
            }
            const binParticleCount = binEnd - binStart;

            // create a species bool in this bin
            const numBinSpecies = Math.floor((maxBinSpecies - minBinSpecies) * Math.random() + minBinSpecies);
            const speciesInBin = [];
            for (var s = 0; s < numBinSpecies; ++s) {
                speciesInBin.push({
                    sx: Math.random() * 2 - 1.0,
                    sy: Math.random() * 2 - 1.0,
                    ax: Math.random() * 2 - 1.0,
                    ay: Math.random() * 2 - 1.0,
                })
            }

            for (var k = 0; k < binParticleCount; ++k) {
                const particleIndex = binStart + k;

                const speciesId = (k % numBinSpecies);

                initialParticles[particleStructSize * particleIndex + 0] = simulationBox[0][0] + (i + Math.random()) * (simulationBox[0][1] - simulationBox[0][0]) / gridSize[0];
                initialParticles[particleStructSize * particleIndex + 1] = simulationBox[1][0] + (j + Math.random()) * (simulationBox[1][1] - simulationBox[1][0]) / gridSize[1];
                initialParticles[particleStructSize * particleIndex + 2] = initialVelocity * (-1.0 + Math.random() * 2.0);
                initialParticles[particleStructSize * particleIndex + 3] = initialVelocity * (-1.0 + Math.random() * 2.0);
                initialParticles[particleStructSize * particleIndex + 4] = speciesInBin[speciesId].sx;
                initialParticles[particleStructSize * particleIndex + 5] = speciesInBin[speciesId].sy;
                initialParticles[particleStructSize * particleIndex + 6] = speciesInBin[speciesId].ax;
                initialParticles[particleStructSize * particleIndex + 7] = speciesInBin[speciesId].ay;
            }
        }
    }

    particleBuffer = device.createBuffer({
        size: particleCount * particleStructSize * 4,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,
    });

    device.queue.writeBuffer(particleBuffer, 0, initialParticles);

    particleTempBuffer = device.createBuffer({
        size: particleBuffer.size,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    binOffsetBuffer = device.createBuffer({
        size: (binCount + 1) * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    });

    binOffsetTempBuffer = device.createBuffer({
        size: (binCount + 1) * 4,
        usage: GPUBufferUsage.STORAGE,
    });

    const binPrefixSumStepSize = new Uint32Array(prefixSumIterations * 64);
    for (var i = 0; i < prefixSumIterations; ++i)
        binPrefixSumStepSize[i * 64] = Math.pow(2, i);

    binPrefixSumStepSizeBuffer = device.createBuffer({
        size: prefixSumIterations * 256,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
    });

    device.queue.writeBuffer(binPrefixSumStepSizeBuffer, 0, binPrefixSumStepSize);

    particleBufferBindGroup = device.createBindGroup({
        layout: particleBufferBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: particleBuffer,
                },
            },
        ],
        label: 'particleBufferBindGroup',
    });

    particleBufferReadOnlyBindGroup = device.createBindGroup({
        layout: particleBufferReadOnlyBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: particleBuffer,
                },
            },
        ],
        label: 'particleBufferReadOnlyBindGroup',
    });

    binFillSizeBindGroup = device.createBindGroup({
        layout: binFillSizeBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
        ],
        label: 'binFillSizeBindGroup',
    });

    binPrefixSumBindGroup[0] = device.createBindGroup({
        layout: binPrefixSumBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
            {
                binding: 1,
                resource: {
                    buffer: binOffsetTempBuffer,
                },
            },
            {
                binding: 2,
                resource: {
                    buffer: binPrefixSumStepSizeBuffer,
                    size: 4,
                },
            },
        ],
    });

    binPrefixSumBindGroup[1] = device.createBindGroup({
        layout: binPrefixSumBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: binOffsetTempBuffer,
                },
            },
            {
                binding: 1,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
            {
                binding: 2,
                resource: {
                    buffer: binPrefixSumStepSizeBuffer,
                    size: 4,
                },
            },
        ],
    });

    particleSortBindGroup = device.createBindGroup({
        layout: particleSortBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: particleBuffer,
                },
            },
            {
                binding: 1,
                resource: {
                    buffer: particleTempBuffer,
                },
            },
            {
                binding: 2,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
            {
                binding: 3,
                resource: {
                    buffer: binOffsetTempBuffer,
                },
            },
        ],
        label: 'particleSortBindGroup',
    });

    particleComputeForcesBindGroup = device.createBindGroup({
        layout: particleComputeForcesBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: particleTempBuffer,
                },
            },
            {
                binding: 1,
                resource: {
                    buffer: particleBuffer,
                },
            },
            {
                binding: 2,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
        ],
        label: 'particleComputeForcesBindGroup',
    });
}

function generateSystem(systemDescription)
{
    const rng = splitmix32(systemDescription.seed);
    systemDescription.maxForceStrength = 1.0;
    systemDescription.collisionStrength = 20.0;
    systemDescription.radius = 0.2;
    systemDescription.collisionRadius = 0.05;
    systemDescription.copyRadius = 0.15;
    systemDescription.copyProbability = 0.001;
    systemDescription.copyCosSimThreshold = 0.8;

    return systemDescription;
}

function initialSystem()
{
    var particleCount = 16384;
    var speciesDim = 2;
    var friction = 0.001;
    var loopingBorders = false;
    var seed = randomSeed();

    const aspectRatio = window.innerWidth / window.innerHeight;
    // Scale based on window size to get values roughly between 2 and 16
    // Fallback to 8 if window dimensions are invalid
    var width = Math.max(2, Math.min(16, Math.round((window.innerWidth || 1920) / 240)));
    var height = Math.max(2, Math.min(16, Math.round((window.innerHeight || 1080) / 240)));

    const urlParams = new URLSearchParams(window.location.search);

    if (urlParams.has("particleCount"))
        particleCount = Number(urlParams.get("particleCount"));

    if (urlParams.has("friction"))
        friction = Number(urlParams.get("friction"));

    if (urlParams.has("loopingBorders"))
        loopingBorders = urlParams.get("loopingBorders") == "true";

    if (urlParams.has("seed"))
        seed = Number(urlParams.get("seed")) >>> 0;

    if (urlParams.has("width"))
        width = Number(urlParams.get("width"));

    if (urlParams.has("height"))
        height = Number(urlParams.get("height"));

    const systemDescription = {
        particleCount: particleCount,
        simulationSize: [width, height],
        friction: friction,
        loopingBorders: loopingBorders,
        seed: seed,
    };
    return generateSystem(systemDescription);
}

function resize()
{
    if (!canvas)
        return;
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    hdrTexture = device.createTexture({
        format: hdrFormat,
        size: [canvas.width, canvas.height, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
    });

    hdrTextureView = hdrTexture.createView({});

    composeBindGroup = device.createBindGroup({
        layout: composeBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: hdrTextureView,
            },
            {
                binding: 1,
                resource: blueNoiseTextureView,
            },
        ],
    });
}

async function loadImage(url) {
    const res = await fetch(url);
    const blob = await res.blob();
    return await createImageBitmap(blob, { colorSpaceConversion: 'none' });
}

async function init()
{
    const buttonsTable = document.getElementById("buttonsTable");
    const toolsPanelStyle = window.getComputedStyle(document.getElementById("toolsPanel"), null);
    buttonsTable.style.width = buttonsTable.parentElement.clientWidth - parseFloat(toolsPanelStyle.getPropertyValue('padding-left')) - parseFloat(toolsPanelStyle.getPropertyValue('padding-right'));

    for (var element of document.getElementsByClassName('slider')) {
        const self = element;
        self.addEventListener('wheel', function(event) {
            self.value = Number(self.value) - event.deltaY / 120;
            self.dispatchEvent(new Event('input'));
        });
    }

    if (!document.body.requestFullscreen) {
        document.getElementById("fullscreenButton").style.display = 'none';
    }

    canvas = document.getElementById("mainCanvas");

    canvas.addEventListener('wheel', function(event) {
        const factor = Math.pow(1.25, event.deltaY / 120);
        cameraExtentXTarget *= factor;

        zoomAnchor = [
            2.0 * event.x / canvas.width - 1.0,
            1.0 - 2.0 * event.y / canvas.height,
        ];

        event.preventDefault();
    }, false);    

    canvas.addEventListener('mousedown', function(event) {
        if (event.button == 0) {
            actionPoint = [event.clientX, event.clientY];
            actionDrag = [0.0, 0.0];
        }
        if (event.button == 2) {
            mouseDrag = [event.clientX, event.clientY];
        }
        event.preventDefault();
    }, false);

    canvas.addEventListener('mouseup', function(event) {
        if (event.button == 0) {
            actionPoint = null;
            actionDrag = null;
        }
        if (event.button == 2) {
            mouseDrag = null;
        }
        event.preventDefault();
    }, false);

    canvas.addEventListener('contextmenu', function(event) {
        event.preventDefault();
    }, false);

    canvas.addEventListener('mousemove', function(event) {
        if (actionPoint) {
            actionDrag = [event.clientX - actionPoint[0], event.clientY - actionPoint[1]];
            actionPoint = [event.clientX, event.clientY];
        }

        if (mouseDrag) {
            const delta = [event.clientX - mouseDrag[0], event.clientY - mouseDrag[1]];

            cameraCenter[0] -= delta[0] / canvas.width * cameraExtentX * 2.0;
            cameraCenter[1] += delta[1] / canvas.height * cameraExtentY * 2.0;

            mouseDrag = [event.clientX, event.clientY];
        }

        event.preventDefault();
    }, false);

    canvas.addEventListener("touchstart", function(event) {
        for (const touch of event.changedTouches) {
            activeTouches.set(touch.identifier, [touch.pageX, touch.pageY]);
        }

        if (activeTouches.size == 3) {
            toolsPanelShown = !toolsPanelShown;
        }

        const now = window.performance.now() / 1000.0;;

        if (activeTouches.size == 1 && (now - lastTouchTime) < 0.5) {
            isDoubleTap = true;
        } else {
            isDoubleTap = false;
        }

        lastTouchTime = now;

        event.preventDefault();
    });

    canvas.addEventListener("touchmove", function(event) {
        const oldTouches = new Map(activeTouches);

        for (const touch of event.changedTouches) {
            activeTouches.set(touch.identifier, [touch.pageX, touch.pageY]);
        }

        if (oldTouches.size == 1 && activeTouches.size == 1) {
            const oldPosition = oldTouches.entries().next().value[1];
            const newPosition = activeTouches.entries().next().value[1];
            const delta = [newPosition[0] - oldPosition[0], newPosition[1] - oldPosition[1]];

            if (isDoubleTap) {
                actionPoint = newPosition;
                actionDrag = delta;
            } else {
                cameraCenter[0] -= delta[0] / canvas.width * cameraExtentX * 2.0;
                cameraCenter[1] += delta[1] / canvas.height * cameraExtentY * 2.0;
            }
        }

        if (oldTouches.size == 2 && activeTouches.size == 2) {
            const oldIterator = oldTouches.entries();
            const newIterator = activeTouches.entries();

            const oldPosition1 = oldIterator.next().value[1];
            const oldPosition2 = oldIterator.next().value[1];

            const newPosition1 = newIterator.next().value[1];
            const newPosition2 = newIterator.next().value[1];

            const oldCenter = [(oldPosition2[0] + oldPosition1[0]) / 2, (oldPosition2[1] + oldPosition1[1]) / 2];
            const newCenter = [(newPosition2[0] + newPosition1[0]) / 2, (newPosition2[1] + newPosition1[1]) / 2];

            zoomAnchor = [
                2.0 * newCenter[0] / canvas.width - 1.0,
                1.0 - 2.0 * newCenter[1] / canvas.height,
            ];

            const delta = [newCenter[0] - oldCenter[0], newCenter[1] - oldCenter[1]];

            const oldDelta = [oldPosition2[0] - oldPosition1[0], oldPosition2[1] - oldPosition1[1]];
            const newDelta = [newPosition2[0] - newPosition1[0], newPosition2[1] - newPosition1[1]];

            const oldDistance = Math.sqrt(oldDelta[0] * oldDelta[0] + oldDelta[1] * oldDelta[1]);
            const newDistance = Math.sqrt(newDelta[0] * newDelta[0] + newDelta[1] * newDelta[1]);

            cameraCenter[0] -= delta[0] / canvas.width * cameraExtentX * 2.0;
            cameraCenter[1] += delta[1] / canvas.height * cameraExtentY * 2.0;
            cameraExtentXTarget *= oldDistance / newDistance;
        }

        event.preventDefault();
    });

    canvas.addEventListener("touchend", function(event) {
        for (const touch of event.changedTouches) {
            activeTouches.delete(touch.identifier);
        }
        isDoubleTap = false;
        actionPoint = null;
        actionDrag = null;
        event.preventDefault();
    });

    canvas.addEventListener("touchcancel", function(event) {
        for (const touch of event.changedTouches) {
            activeTouches.delete(touch.identifier);
        }
        isDoubleTap = false;
        actionPoint = null;
        actionDrag = null;
    });

    window.addEventListener('keydown',function(event) {
        if (event.key == ' ') {
            pauseClicked();
            event.preventDefault();
        }

        if (event.key == 'c') {
            centerView();
            event.preventDefault();
        }

        if (event.key == 's') {
            toolsPanelShown = !toolsPanelShown;
            event.preventDefault();
        }

        if (event.key == 'd') {
            debugPanelShown = !debugPanelShown;
            event.preventDefault();
        }
    }, false);

    if (!navigator) {
        alert("Your browser doesn't support WebGPU (navigator is null)");
        return;
    }

    if (!navigator.gpu) {
        alert("Your browser doesn't support WebGPU (navigator.gpu is null)");
        return;
    }

    const adapter = await navigator.gpu?.requestAdapter();

    if (!adapter) {
        alert("Your browser doesn't support WebGPU (failed to create adapter)");
        return;
    }

    timestampQuerySupported = adapter.features.has('timestamp-query');

    device = await adapter?.requestDevice({
        requiredFeatures: timestampQuerySupported ? ['timestamp-query'] : [],
    });

    if (!device) {
        alert("Your browser doesn't support WebGPU (failed to create device)");
        return;
    }

    context = canvas.getContext('webgpu');
    surfaceFormat = navigator.gpu.getPreferredCanvasFormat();
    context.configure({
        device,
        format: surfaceFormat,
    });

    cameraBuffer = device.createBuffer({
        size: 24,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
    });

    simulationOptionsBuffer = device.createBuffer({
        size: 23 * 4,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
    });

    const binFillSizeShaderModule = device.createShaderModule({
        code: binFillSizeShader,
        label: 'binFillSizeShaderModule',
    });

    const binPrefixSumShaderModule = device.createShaderModule({
        code: binPrefixSumShader,
        label: 'binPrefixSumShaderModule',
    });

    const particleSortShaderModule = device.createShaderModule({
        code: particleSortShader,
        label: 'particleSortShaderModule',
    });

    const particleComputeForcesShaderModule = device.createShaderModule({
        code: particleComputeForcesShader,
        label: 'particleComputeForcesShaderModule',
    });

    const particleAdvanceShaderModule = device.createShaderModule({
        code: particleAdvanceShader,
        label: 'particleAdvanceShaderModule',
    });

    const particleRenderShaderModule = device.createShaderModule({
        code: particleRenderShader,
        label: 'particleRenderShaderModule',
    });

    const composeShaderModule = device.createShaderModule({
        code: composeShader,
        label: 'composeShaderModule',
    });

    particleBufferBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
        label: 'particleBufferBindGroupLayout',
    });

    particleBufferReadOnlyBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
        ],
        label: 'particleBufferReadOnlyBindGroupLayout',
    });

    cameraBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                buffer: {
                    type: 'uniform',
                },
            },
        ],
        label: 'cameraBindGroupLayout',
    });

    cameraBindGroup = device.createBindGroup({
        layout: cameraBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: cameraBuffer,
                },
            },
        ],
        label: 'cameraBindGroup',
    });

    simulationOptionsBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                },
            },
        ],
        label: 'simulationOptionsBindGroupLayout',
    });

    simulationOptionsBindGroup = device.createBindGroup({
        layout: simulationOptionsBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: simulationOptionsBuffer,
                },
            },
        ],
        label: 'simulationOptionsBindGroup',
    });

    binFillSizeBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
        label: 'binFillSizeBindGroupLayout',
    });

    binPrefixSumBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                    hasDynamicOffset: true,
                },
            },
        ],
    });

    particleSortBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 3,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });

    particleComputeForcesBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
        ],
        label: 'particleComputeForcesBindGroupLayout',
    });

    composeBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {},
            },
            {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {},
            },
        ],
    });

    binClearSizePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                simulationOptionsBindGroupLayout,
                binFillSizeBindGroupLayout,
            ],
        }),
        compute: {
            module: binFillSizeShaderModule,
            entryPoint: 'clearBinSize',
        },
        label: 'binClearSizePipeline',
    });

    binFillSizePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                simulationOptionsBindGroupLayout,
                binFillSizeBindGroupLayout,
            ],
        }),
        compute: {
            module: binFillSizeShaderModule,
            entryPoint: 'fillBinSize',
        },
        label: 'binFillSizePipeline',
    });

    binPrefixSumPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                binPrefixSumBindGroupLayout,
            ],
        }),
        compute: {
            module: binPrefixSumShaderModule,
            entryPoint: 'prefixSumStep',
        },
        label: 'binPrefixSumPipeline',
    });

    particleSortClearSizePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleSortBindGroupLayout,
                simulationOptionsBindGroupLayout,
            ],
        }),
        compute: {
            module: particleSortShaderModule,
            entryPoint: 'clearBinSize',
        },
        label: 'particleSortClearSizePipeline',
    });

    particleSortPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleSortBindGroupLayout,
                simulationOptionsBindGroupLayout,
            ],
        }),
        compute: {
            module: particleSortShaderModule,
            entryPoint: 'sortParticles',
        },
        label: 'particleSortPipeline',
    });

    particleComputeForcesPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleComputeForcesBindGroupLayout,
                simulationOptionsBindGroupLayout,
            ],
        }),
        compute: {
            module: particleComputeForcesShaderModule,
            entryPoint: 'computeForces',
        },
        label: 'particleComputeForcesPipeline',
    });

    particleAdvancePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferBindGroupLayout,
                simulationOptionsBindGroupLayout,
            ],
        }),
        compute: {
            module: particleAdvanceShaderModule,
            entryPoint: 'particleAdvance',
        },
        label: 'particleAdvancePipeline',
    });

    particleRenderGlowPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                cameraBindGroupLayout,
            ],
        }),
        vertex: {
            module: particleRenderShaderModule,
            entryPoint: 'vertexGlow',
        },
        primitive: {
            topology: 'triangle-list',
        },
        fragment: {
            module: particleRenderShaderModule,
            entryPoint: 'fragmentGlow',
            targets: [
                {
                    format: hdrFormat,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one',
                        },
                        alpha: {
                            srcFactor: 'one',
                            dstFactor: 'one',
                        },
                    },
                },
            ],
        },
        label: 'particleRenderGlowPipeline',
    });

    particleRenderPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                cameraBindGroupLayout,
            ],
        }),
        vertex: {
            module: particleRenderShaderModule,
            entryPoint: 'vertexCircle',
        },
        primitive: {
            topology: 'triangle-list',
        },
        fragment: {
            module: particleRenderShaderModule,
            entryPoint: 'fragmentCircle',
            targets: [
                {
                    format: hdrFormat,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one',
                        },
                        alpha: {
                            srcFactor: 'one',
                            dstFactor: 'one',
                        },
                    },
                },
            ],
        },
        label: 'particleRenderPipeline',
    });

    particleRenderPointPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                cameraBindGroupLayout,
            ],
        }),
        vertex: {
            module: particleRenderShaderModule,
            entryPoint: 'vertexPoint',
        },
        primitive: {
            topology: 'triangle-list',
        },
        fragment: {
            module: particleRenderShaderModule,
            entryPoint: 'fragmentPoint',
            targets: [
                {
                    format: hdrFormat,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one',
                        },
                        alpha: {
                            srcFactor: 'one',
                            dstFactor: 'one',
                        },
                    },
                },
            ],
        },
        label: 'particleRenderPointPipeline',
    });

    composePipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                composeBindGroupLayout,
            ],
        }),
        vertex: {
            module: composeShaderModule,
            entryPoint: 'vertexMain',
        },
        primitive: {
            topology: 'triangle-list',
        },
        fragment: {
            module: composeShaderModule,
            entryPoint: 'fragmentMain',
            targets: [
                {
                    format: surfaceFormat,
                },
            ],
        },
        label: 'composePipeline',
    });

    const blueNoiseImage = await loadImage("/webgpu/blue-noise.png");
    blueNoiseTexture = device.createTexture({
        format: 'rgba8unorm-srgb',
        size: [blueNoiseImage.width, blueNoiseImage.height],
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
    });
    device.queue.copyExternalImageToTexture(
        {source: blueNoiseImage},
        {texture: blueNoiseTexture},
        {width: blueNoiseImage.width, height: blueNoiseImage.height},
    );

    blueNoiseTextureView = blueNoiseTexture.createView({});

    resize();

    loadSystem(initialSystem());
    centerView();

    redraw();
}

window.onload = init;
window.onresize = resize;

function pauseClicked()
{
    paused = !paused;
    document.getElementById("pauseButton").innerText = paused ? "Continue" : "Pause";
}

function updateParticleCount()
{
    const newParticleCount = Math.round(Math.pow(2, document.getElementById("particleCountSlider").value));

    const systemDescription = currentSystemDescription;
    systemDescription.particleCount = newParticleCount;
    loadSystem(systemDescription);
}

function updateSimulationSize()
{
    const newWidth = document.getElementById("simulationWidthSlider").value;
    const newHeight = document.getElementById("simulationHeightSlider").value;

    const systemDescription = currentSystemDescription;
    systemDescription.simulationSize = [newWidth, newHeight];
    loadSystem(systemDescription);
}

function updateFriction()
{
    const newFriction = parseFloat(document.getElementById("frictionSlider").value);

    currentSystemDescription.friction = newFriction;
    friction = newFriction;

    document.getElementById("frictionText").innerText = `Friction: ${newFriction}`;
}

function updateMaxForceStrength()
{
    const newMaxForceStrength = parseFloat(document.getElementById("maxForceStrengthSlider").value);

    currentSystemDescription.maxForceStrength = newMaxForceStrength;

    document.getElementById("maxForceStrengthText").innerText = `Max force strength: ${newMaxForceStrength.toFixed(1)}`;
}

function updateRadius()
{
    const newRadius = parseFloat(document.getElementById("forceRadiusSlider").value);

    currentSystemDescription.radius = newRadius;

    document.getElementById("forceRadiusText").innerText = `Force radius: ${newRadius.toFixed(1)}`;
}

function updateCollisionStrength()
{
    const newCollisionStrength = parseFloat(document.getElementById("collisionStrengthSlider").value);

    currentSystemDescription.collisionStrength = newCollisionStrength;

    document.getElementById("collisionStrengthText").innerText = `Collision strength: ${newCollisionStrength.toFixed(1)}`;
}

function updateCollisionRadius()
{
    const newCollisionRadius = parseFloat(document.getElementById("collisionRadiusSlider").value);

    currentSystemDescription.collisionRadius = newCollisionRadius;

    document.getElementById("collisionRadiusText").innerText = `Collision radius: ${newCollisionRadius.toFixed(2)}`;
}

function updateLoopingBorders()
{
    const newLoopingBorders = document.getElementById("loopingBorders").checked;

    currentSystemDescription.loopingBorders = newLoopingBorders;
    loopingBorders = newLoopingBorders;
}

async function saveSettings()
{
    const handle = await window.showSaveFilePicker({
        id: "particle-life",
        startIn: "downloads",
        suggestedName: "particle-life-system.json",
        types: [{
            description: "JSON file",
            accept: {"application/json": [".json"]},
        }],
    });

    const writable = await handle.createWritable();
    await writable.write(JSON.stringify(currentSystemDescription, null, 2));
    await writable.close();
}

async function loadSettings()
{
    const [handle] = await window.showOpenFilePicker({
        id: "particle-life",
        startIn: "downloads",
        suggestedName: "particle-life-system.json",
        types: [{
            description: "JSON file",
            accept: {"application/json": [".json"]},
        }],
    });

    const file = await handle.getFile();
    const data = await file.text();
    loadSystem(JSON.parse(data));
    customRules = true;
}

async function copyUrl()
{    
    if (customRules) {
        alert("Copying URL might not work correctly with custom rules");
    }

    const location = window.location;
    var url = location.protocol + "//" + location.host + location.pathname + `?particleCount=${particleCount}&friction=${friction}&loopingBorders=${loopingBorders}&seed=${currentSystemDescription.seed}`;

    await navigator.clipboard.writeText(url);
}

async function fullscreen()
{
    if (document.fullscreen) {
        await document.exitFullscreen();
        document.getElementById("fullscreenButton").innerText = "Fullscreen";
    } else {
        await document.body.requestFullscreen();
        document.getElementById("fullscreenButton").innerText = "Exit fullscreen";
    }
}

        </script>
        <style>
            #mainCanvas {
                position: fixed;
            }

            #copyright {
                position: fixed;
                left: 12px;
                bottom: 12px;
                color: #bbb;
                font-family: monospace;
                font-size: 14;
            }

            .panel {
                background-color: rgba(50, 50, 50, 0.5);
                border-radius: 12px;
                border: 2px solid #eee;
                color: #eee;
                padding: 18px;
                backdrop-filter: blur(4px);
                font-family: monospace;
                font-size: 14;
            }

            #toolsPanel {
                position: fixed;
                left: 24px;
                top: 24px;
            }

            #debugPanel {
                position: fixed;
                right: 24px;
                top: 24px;
            }

            #debugInfo {
                white-space: pre;
            }

            a {
                color: #bbb;
                text-decoration: none;
            }

            a:hover {
                color: #eee;
                text-decoration: underline;
            }

            label {
                font-family: monospace;
                font-size: 14;
                color: #eee;
            }

            .checkboxContainer input {
                position: absolute;
                opacity: 0;
                cursor: pointer;
                height: 0;
                width: 0;
            }

            .checkboxContainer {
                display: block;
                position: relative;
                cursor: pointer;
                padding-left: 28px;
                padding-top: 14px;
                padding-bottom: 10px;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            .customCheckbox {
                position: absolute;
                top: 12px;
                left: 0px;
                height: 20px;
                width: 20px;
                background-color: #eee;
                border-radius: 4px;
            }

            .checkboxContainer input:active ~ .customCheckbox {
                top: 13px;
                left: 1px;
            }

            .checkboxContainer:hover input ~ .customCheckbox {
                background-color: #999;
            }

            .checkboxContainer input:checked ~ .customCheckbox {
                background-color: #777;
            }

            .checkboxContainer:hover input:checked ~ .customCheckbox {
                background-color: #555;
            }

            .customCheckbox:after {
                content: "";
                position: absolute;
                display: none;
            }

            .checkboxContainer input:checked ~ .customCheckbox:after {
                display: block;
            }

            .checkboxContainer .customCheckbox:after {
                left: 6px;
                top: 2px;
                width: 5px;
                height: 10px;
                border: solid white;
                border-width: 0 3px 3px 0;
                -webkit-transform: rotate(45deg);
                -ms-transform: rotate(45deg);
                transform: rotate(45deg);
            }

            .button {
                background-color: #777;
                padding: 4px;
                border-radius: 4px;
                text-align: center;
                cursor: pointer;
            }

            .button:hover {
                background-color: #555;
            }

            .button:active {
                background-color: #444;
            }

            .rowBreak {
                height: 8px;
            }

            .sliderContainer input {
                -webkit-appearance: none;
                appearance: none;
                height: 4px;
                border-radius: 2px;
                background: #ccc;
                outline: none;
            }

            .sliderContainer input:hover {
                background: #999;
            }

            .sliderContainer input::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 16px;
                height: 16px;
                border-radius: 8px;
                border: 2px solid #ccc;
                background: #777;
                cursor: pointer;
            }

            .sliderContainer input::-webkit-slider-thumb:hover  {
                background: #555;
                border: 2px solid #999;
            }

            table {
                table-layout: fixed;
                border: none;
                border-collapse: collapse;
                color: #eee;
            }
        </style>
    </head>
    <body>
        <canvas id="mainCanvas"></canvas>
        <div id="copyright"><a href="/blog/posts/particle-life-simulation-in-browser-using-webgpu.html">About</a><br>by <a href="https://lisyarus.github.io/blog">@lisyarus</a></div>
        <div id="toolsPanel" class="panel">
            <div class="sliderContainer">
                <input type="range" min="10" max="20" value="16" class="slider" id="particleCountSlider" oninput="updateParticleCount();">
                <span id="particleCountText">65536 particles</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="2" max="32" value="8" class="slider" id="simulationWidthSlider" oninput="updateSimulationSize();">
                <span id="simulationWidthText">Width: 16</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="2" max="32" value="8" class="slider" id="simulationHeightSlider" oninput="updateSimulationSize();">
                <span id="simulationHeightText">Height: 4</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="0" max="0.1" value="0.001" class="slider" id="frictionSlider" oninput="updateFriction();">
                <span id="frictionText">Friction: 0.001</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="0" max="100" value="100" class="slider" id="maxForceStrengthSlider" oninput="updateMaxForceStrength();">
                <span id="maxForceStrengthText">Max force strength: 100</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="5" max="32" value="32" class="slider" id="forceRadiusSlider" oninput="updateRadius();">
                <span id="forceRadiusText">Radius: 32</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="5" max="100" value="100" class="slider" id="collisionStrengthSlider" oninput="updateCollisionStrength();">
                <span id="collisionStrengthText">Collision strength: 10</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="1" max="32" value="16" class="slider" id="collisionRadiusSlider" oninput="updateCollisionRadius();">
                <span id="collisionRadiusText">Collision radius: 16</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="1" max="32" value="8" class="slider" id="copyRadiusSlider" oninput="updateCopyRadius();">
                <span id="copyRadiusText">Copy radius: 8</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="-1" max="1" value="0.5" class="slider" id="copyCosSimThresholdSlider" oninput="updateCopyCosSimThreshold();">
                <span id="copyCosSimThresholdText">Copy cosine similarity threshold: 0.5</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="0" max="1" value="0.001" class="slider" id="copyProbSlider" oninput="updateCopyProb();">
                <span id="copyProbText">Copy probability: 0.001</span>
            </div>
            <div class="rowBreak"></div>
            <label class="checkboxContainer">
                Looping borders
                <input type="checkbox" id="loopingBorders" onclick="updateLoopingBorders();" />
                <span class="customCheckbox"></span>
            </label>
            <div class="rowBreak"></div>
            <table id="buttonsTable">
                <tr>
                    <td><div class="button" id="pauseButton" onclick="pauseClicked();">Pause</div></td>
                    <td><div class="button" id="centerViewButton" onclick="centerView();">Center view</div></td>
                </tr>
                <tr>
                    <td><div class="button" id="restartButton" onclick="loadSystem(currentSystemDescription);">Restart</div></td>
                    <td><div class="button" id="randomizeButton" onclick="currentSystemDescription.seed = randomSeed(); loadSystem(generateSystem(currentSystemDescription));">Randomize</div></td>
                </tr>
                <tr>
                    <td><div class="button" id="saveSettingsButton" onclick="saveSettings();">Save system</div></td>
                    <td><div class="button" id="loadSettingsButton" onclick="loadSettings();">Load system</div></td>
                </tr>
                <tr>
                    <td><div class="button" id="copyUrlButton" onclick="copyUrl();">Copy URL</div></td>
                    <td><div class="button" id="fullscreenButton" onclick="fullscreen();">Fullscreen</div></td>
                </tr>
            </table>
            
            <div class="rowBreak"></div>
            <div><center>[S] or three-tap to hide this menu</center></div>
            <div><center>LMB or double-tap to interact</center></div>
        </div>
        <div id="debugPanel" class="panel">
            <div id="debugInfo">Debug info</div>
        </div>
    </body>
</html>

